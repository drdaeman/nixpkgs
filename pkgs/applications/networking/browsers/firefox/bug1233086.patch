diff -urN a/toolkit/components/alerts/AlertNotification.cpp b/toolkit/components/alerts/AlertNotification.cpp
--- a/toolkit/components/alerts/AlertNotification.cpp	2016-06-01 07:11:40.000000000 +0300
+++ b/toolkit/components/alerts/AlertNotification.cpp	2016-09-18 18:14:46.164274802 +0300
@@ -4,21 +4,24 @@
 
 #include "mozilla/AlertNotification.h"
 
+#include "imgIContainer.h"
+#include "imgINotificationObserver.h"
+#include "imgIRequest.h"
+#include "imgLoader.h"
 #include "nsAlertsUtils.h"
+#include "nsComponentManagerUtils.h"
+#include "nsContentUtils.h"
+#include "nsNetUtil.h"
+#include "nsServiceManagerUtils.h"
+
+#include "mozilla/unused.h"
 
 namespace mozilla {
 
-NS_IMPL_CYCLE_COLLECTION(AlertNotification, mPrincipal)
-NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(AlertNotification)
-  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIAlertNotification)
-  NS_INTERFACE_MAP_ENTRY(nsIAlertNotification)
-NS_INTERFACE_MAP_END
-NS_IMPL_CYCLE_COLLECTING_ADDREF(AlertNotification)
-NS_IMPL_CYCLE_COLLECTING_RELEASE(AlertNotification)
+NS_IMPL_ISUPPORTS(AlertNotification, nsIAlertNotification)
 
 AlertNotification::AlertNotification()
   : mTextClickable(false)
-  , mPrincipal(nullptr)
   , mInPrivateBrowsing(false)
 {}
 
@@ -148,4 +151,203 @@
   return NS_OK;
 }
 
+NS_IMETHODIMP
+AlertNotification::LoadImage(uint32_t aTimeout,
+                             nsIAlertNotificationImageListener* aListener,
+                             nsISupports* aUserData,
+                             nsICancelable** aRequest)
+{
+  NS_ENSURE_ARG(aListener);
+  NS_ENSURE_ARG_POINTER(aRequest);
+  *aRequest = nullptr;
+
+  // Exit early if this alert doesn't have an image.
+  if (mImageURL.IsEmpty()) {
+    return aListener->OnImageMissing(aUserData);
+  }
+  nsCOMPtr<nsIURI> imageURI;
+  NS_NewURI(getter_AddRefs(imageURI), mImageURL);
+  if (!imageURI) {
+    return aListener->OnImageMissing(aUserData);
+  }
+
+  RefPtr<AlertImageRequest> request = new AlertImageRequest(imageURI, mPrincipal,
+                                                            mInPrivateBrowsing,
+                                                            aTimeout, aListener,
+                                                            aUserData);
+  nsresult rv = request->Start();
+  request.forget(aRequest);
+  return rv;
+}
+
+NS_IMPL_CYCLE_COLLECTION(AlertImageRequest, mURI, mPrincipal, mListener,
+                         mUserData)
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(AlertImageRequest)
+  NS_INTERFACE_MAP_ENTRY(imgINotificationObserver)
+  NS_INTERFACE_MAP_ENTRY(nsICancelable)
+  NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, imgINotificationObserver)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(AlertImageRequest)
+NS_IMPL_CYCLE_COLLECTING_RELEASE(AlertImageRequest)
+
+AlertImageRequest::AlertImageRequest(nsIURI* aURI, nsIPrincipal* aPrincipal,
+                                     bool aInPrivateBrowsing, uint32_t aTimeout,
+                                     nsIAlertNotificationImageListener* aListener,
+                                     nsISupports* aUserData)
+  : mURI(aURI)
+  , mPrincipal(aPrincipal)
+  , mInPrivateBrowsing(aInPrivateBrowsing)
+  , mTimeout(aTimeout)
+  , mListener(aListener)
+  , mUserData(aUserData)
+{}
+
+AlertImageRequest::~AlertImageRequest()
+{
+  if (mRequest) {
+    mRequest->CancelAndForgetObserver(NS_BINDING_ABORTED);
+  }
+}
+
+NS_IMETHODIMP
+AlertImageRequest::Notify(imgIRequest* aRequest, int32_t aType,
+                          const nsIntRect* aData)
+{
+  MOZ_ASSERT(aRequest == mRequest);
+
+  uint32_t imgStatus = imgIRequest::STATUS_ERROR;
+  nsresult rv = aRequest->GetImageStatus(&imgStatus);
+  if (NS_WARN_IF(NS_FAILED(rv)) ||
+      (imgStatus & imgIRequest::STATUS_ERROR)) {
+    return NotifyMissing();
+  }
+
+  // If the image is already decoded, `FRAME_COMPLETE` will fire before
+  // `LOAD_COMPLETE`, so we can notify the listener immediately. Otherwise,
+  // we'll need to request a decode when `LOAD_COMPLETE` fires, and wait
+  // for the first frame.
+
+  if (aType == imgINotificationObserver::LOAD_COMPLETE) {
+    if (!(imgStatus & imgIRequest::STATUS_FRAME_COMPLETE)) {
+      nsCOMPtr<imgIContainer> image;
+      rv = aRequest->GetImage(getter_AddRefs(image));
+      if (NS_WARN_IF(NS_FAILED(rv) || !image)) {
+        return NotifyMissing();
+      }
+
+      // Ask the image to decode at its intrinsic size.
+      int32_t width = 0, height = 0;
+      image->GetWidth(&width);
+      image->GetHeight(&height);
+      image->RequestDecodeForSize(gfx::IntSize(width, height), imgIContainer::FLAG_NONE);
+    }
+    return NS_OK;
+  }
+
+  if (aType == imgINotificationObserver::FRAME_COMPLETE) {
+    return NotifyComplete();
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+AlertImageRequest::Notify(nsITimer* aTimer)
+{
+  MOZ_ASSERT(aTimer == mTimer);
+  return NotifyMissing();
+}
+
+NS_IMETHODIMP
+AlertImageRequest::Cancel(nsresult aReason)
+{
+  if (mRequest) {
+    mRequest->Cancel(aReason);
+  }
+  // We call `NotifyMissing` here because we won't receive a `LOAD_COMPLETE`
+  // notification if we cancel the request before it loads (bug 1233086,
+  // comment 33). Once that's fixed, `nsIAlertNotification::loadImage` could
+  // return the underlying `imgIRequest` instead of the wrapper.
+  return NotifyMissing();
+}
+
+nsresult
+AlertImageRequest::Start()
+{
+  // Keep the request alive until we notify the image listener.
+  NS_ADDREF_THIS();
+
+  nsresult rv;
+  if (mTimeout > 0) {
+    mTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
+    if (NS_WARN_IF(!mTimer)) {
+      return NotifyMissing();
+    }
+    rv = mTimer->InitWithCallback(this, mTimeout,
+                                  nsITimer::TYPE_ONE_SHOT);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return NotifyMissing();
+    }
+  }
+
+  // Begin loading the image.
+  nsCOMPtr<imgILoader> il(do_GetService("@mozilla.org/image/loader;1"));
+  if (!il) {
+    return NotifyMissing();
+  }
+
+  // Bug 1237405: `LOAD_ANONYMOUS` disables cookies, but we want to use a
+  // temporary cookie jar instead. We should also use
+  // `imgLoader::PrivateBrowsingLoader()` instead of the normal loader.
+  // Unfortunately, the PB loader checks the load group, and asserts if its
+  // load context's PB flag isn't set. The fix is to pass the load group to
+  // `nsIAlertNotification::loadImage`.
+  int32_t loadFlags = mInPrivateBrowsing ? nsIRequest::LOAD_ANONYMOUS :
+                      nsIRequest::LOAD_NORMAL;
+
+  rv = il->LoadImageXPCOM(mURI, nullptr, nullptr,
+                          NS_LITERAL_STRING("default"), mPrincipal, nullptr,
+                          this, nullptr, loadFlags, nullptr,
+                          nsIContentPolicy::TYPE_INTERNAL_IMAGE,
+                          getter_AddRefs(mRequest));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return NotifyMissing();
+  }
+
+  return NS_OK;
+}
+
+nsresult
+AlertImageRequest::NotifyMissing()
+{
+  if (mTimer) {
+    mTimer->Cancel();
+    mTimer = nullptr;
+  }
+  if (nsCOMPtr<nsIAlertNotificationImageListener> listener = mListener.forget()) {
+    nsresult rv = listener->OnImageMissing(mUserData);
+    NS_RELEASE_THIS();
+    return rv;
+  }
+  return NS_OK;
+}
+
+nsresult
+AlertImageRequest::NotifyComplete()
+{
+  if (mTimer) {
+    mTimer->Cancel();
+    mTimer = nullptr;
+  }
+  if (nsCOMPtr<nsIAlertNotificationImageListener> listener = mListener.forget()) {
+    nsresult rv = listener->OnImageReady(mUserData, mRequest);
+    NS_RELEASE_THIS();
+    return rv;
+  }
+  return NS_OK;
+}
+
 } // namespace mozilla
diff -urN a/toolkit/components/alerts/AlertNotification.h b/toolkit/components/alerts/AlertNotification.h
--- a/toolkit/components/alerts/AlertNotification.h	2016-05-12 20:13:26.000000000 +0300
+++ b/toolkit/components/alerts/AlertNotification.h	2016-09-18 16:58:23.401616230 +0300
@@ -5,20 +5,56 @@
 #ifndef mozilla_AlertNotification_h__
 #define mozilla_AlertNotification_h__
 
+#include "imgINotificationObserver.h"
 #include "nsIAlertsService.h"
 #include "nsCOMPtr.h"
 #include "nsCycleCollectionParticipant.h"
+#include "nsICancelable.h"
 #include "nsIPrincipal.h"
 #include "nsString.h"
+#include "nsITimer.h"
 
 namespace mozilla {
 
-class AlertNotification final : public nsIAlertNotification
+class AlertImageRequest final : public imgINotificationObserver,
+                                public nsICancelable,
+                                public nsITimerCallback
 {
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
-  NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(AlertNotification,
-                                           nsIAlertNotification)
+  NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(AlertImageRequest,
+                                           imgINotificationObserver)
+  NS_DECL_IMGINOTIFICATIONOBSERVER
+  NS_DECL_NSICANCELABLE
+  NS_DECL_NSITIMERCALLBACK
+
+  AlertImageRequest(nsIURI* aURI, nsIPrincipal* aPrincipal,
+                    bool aInPrivateBrowsing, uint32_t aTimeout,
+                    nsIAlertNotificationImageListener* aListener,
+                    nsISupports* aUserData);
+
+  nsresult Start();
+
+private:
+  virtual ~AlertImageRequest();
+
+  nsresult NotifyMissing();
+  nsresult NotifyComplete();
+
+  nsCOMPtr<nsIURI> mURI;
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+  bool mInPrivateBrowsing;
+  uint32_t mTimeout;
+  nsCOMPtr<nsIAlertNotificationImageListener> mListener;
+  nsCOMPtr<nsISupports> mUserData;
+  nsCOMPtr<nsITimer> mTimer;
+  nsCOMPtr<imgIRequest> mRequest;
+};
+
+class AlertNotification final : public nsIAlertNotification
+{
+public:
+  NS_DECL_ISUPPORTS
   NS_DECL_NSIALERTNOTIFICATION
   AlertNotification();
 
diff -urN a/toolkit/components/alerts/nsIAlertsService.idl b/toolkit/components/alerts/nsIAlertsService.idl
--- a/toolkit/components/alerts/nsIAlertsService.idl	2016-06-01 07:11:40.000000000 +0300
+++ b/toolkit/components/alerts/nsIAlertsService.idl	2016-09-18 17:10:58.964891584 +0300
@@ -6,6 +6,8 @@
 #include "nsISupports.idl"
 #include "nsIObserver.idl"
 
+interface imgIRequest;
+interface nsICancelable;
 interface nsIPrincipal;
 interface nsIURI;
 
@@ -13,21 +15,41 @@
 #define ALERT_NOTIFICATION_CONTRACTID "@mozilla.org/alert-notification;1"
 %}
 
-[scriptable, uuid(1650a064-79d5-4eb6-8c9e-57dd6522b6ac)]
+[scriptable, uuid(a71a637d-de1d-47c6-a8d2-c60b2596f471)]
+interface nsIAlertNotificationImageListener : nsISupports
+{
+  /**
+   * Called when the image finishes loading.
+   *
+   * @param aUserData An opaque parameter passed to |loadImage|.
+   * @param aRequest  The image request.
+   */
+  void onImageReady(in nsISupports aUserData, in imgIRequest aRequest);
+
+  /**
+   * Called if the alert doesn't have an image, or if the image request times
+   * out or fails.
+   *
+   * @param aUserData An opaque parameter passed to |loadImage|.
+   */
+  void onImageMissing(in nsISupports aUserData);
+};
+
+[scriptable, uuid(cf2e4cb6-4b8f-4eca-aea9-d51a8f9f7a50)]
 interface nsIAlertNotification : nsISupports
 {
   /** Initializes an alert notification. */
-  void init([optional] in AString name,
-            [optional] in AString imageURL,
-            [optional] in AString title,
-            [optional] in AString text,
-            [optional] in boolean textClickable,
-            [optional] in AString cookie,
-            [optional] in AString dir,
-            [optional] in AString lang,
-            [optional] in AString data,
-            [optional] in nsIPrincipal principal,
-            [optional] in boolean inPrivateBrowsing);
+  void init([optional] in AString aName,
+            [optional] in AString aImageURL,
+            [optional] in AString aTitle,
+            [optional] in AString aText,
+            [optional] in boolean aTextClickable,
+            [optional] in AString aCookie,
+            [optional] in AString aDir,
+            [optional] in AString aLang,
+            [optional] in AString aData,
+            [optional] in nsIPrincipal aPrincipal,
+            [optional] in boolean aInPrivateBrowsing);
 
   /**
    * The name of the notification. On Android, the name is hashed and used as
@@ -93,8 +115,8 @@
   readonly attribute nsIURI URI;
 
   /**
-   * Controls the image loading behavior. If true, the image URL will be loaded
-   * in private browsing mode.
+   * Controls the image loading behavior. If true, the image request will be
+   * loaded anonymously (without cookies or authorization tokens).
    */
   readonly attribute boolean inPrivateBrowsing;
 
@@ -110,18 +132,34 @@
    * is not actionable.
    */
   readonly attribute AString source;
+
+  /**
+   * Loads the image associated with this alert.
+   *
+   * @param aTimeout  The number of milliseconds to wait before cancelling the
+   *                  image request. If zero, there is no timeout.
+   * @param aListener An |nsIAlertNotificationImageListener| implementation,
+   *                  notified when the image loads. The listener is kept alive
+   *                  until the request completes.
+   * @param aUserData An opaque parameter passed to the listener's methods.
+   *                  Not used by the libnotify backend, but the OS X backend
+   *                  passes the pending notification.
+   */
+  nsICancelable loadImage(in unsigned long aTimeout,
+                          in nsIAlertNotificationImageListener aListener,
+                          [optional] in nsISupports aUserData);
 };
 
 [scriptable, uuid(f7a36392-d98b-4141-a7d7-4e46642684e3)]
 interface nsIAlertsService : nsISupports
 {
-  void showAlert(in nsIAlertNotification alert,
-                 [optional] in nsIObserver alertListener);
+  void showAlert(in nsIAlertNotification aAlert,
+                 [optional] in nsIObserver aAlertListener);
   /**
    * Initializes and shows an |nsIAlertNotification| with the given parameters.
    *
-   * @param alertListener  Used for callbacks. May be null if the caller
-   *                       doesn't care about callbacks.
+   * @param aAlertListener  Used for callbacks. May be null if the caller
+   *                        doesn't care about callbacks.
    * @see nsIAlertNotification for descriptions of all other parameters.
    * @throws NS_ERROR_NOT_AVAILABLE If the notification cannot be displayed.
    *
@@ -140,28 +178,28 @@
    *       In that case, if an alert listener is passed in it will receive the
    *       "alertfinished" notification immediately.
    */
-  void showAlertNotification(in AString  imageUrl,
-                             in AString  title,
-                             in AString  text,
-                             [optional] in boolean textClickable,
-                             [optional] in AString cookie,
-                             [optional] in nsIObserver alertListener,
-                             [optional] in AString name,
-                             [optional] in AString dir,
-                             [optional] in AString lang,
-                             [optional] in AString data,
-                             [optional] in nsIPrincipal principal,
-                             [optional] in boolean inPrivateBrowsing);
+  void showAlertNotification(in AString aImageURL,
+                             in AString aTitle,
+                             in AString aText,
+                             [optional] in boolean aTextClickable,
+                             [optional] in AString aCookie,
+                             [optional] in nsIObserver aAlertListener,
+                             [optional] in AString aName,
+                             [optional] in AString aDir,
+                             [optional] in AString aLang,
+                             [optional] in AString aData,
+                             [optional] in nsIPrincipal aPrincipal,
+                             [optional] in boolean aInPrivateBrowsing);
 
   /**
    * Close alerts created by the service.
    *
-   * @param name           The name of the notification to close. If no name
+   * @param aName          The name of the notification to close. If no name
    *                       is provided then only a notification created with
    *                       no name (if any) will be closed.
    */
-  void closeAlert([optional] in AString name,
-                  [optional] in nsIPrincipal principal);
+  void closeAlert([optional] in AString aName,
+                  [optional] in nsIPrincipal aPrincipal);
 
 };
 
@@ -187,27 +225,27 @@
    * Called to notify the alert service that progress has occurred for the
    * given notification previously displayed with showAlertNotification().
    *
-   * @param name         The name of the notification displaying the
+   * @param aName        The name of the notification displaying the
    *                     progress. On Android the name is hashed and used
    *                     as a notification ID.
-   * @param progress     Numeric value in the range 0 to progressMax
+   * @param aProgress    Numeric value in the range 0 to progressMax
    *                     indicating the current progress.
-   * @param progressMax  Numeric value indicating the maximum progress.
-   * @param text         The contents of the alert. If not provided,
+   * @param aProgressMax Numeric value indicating the maximum progress.
+   * @param aText        The contents of the alert. If not provided,
    *                     the percentage will be displayed.
    */
-  void onProgress(in AString name,
-                  in long long progress,
-                  in long long progressMax,
-                  [optional] in AString text);
+  void onProgress(in AString aName,
+                  in long long aProgress,
+                  in long long aProgressMax,
+                  [optional] in AString aText);
 
   /**
    * Called to cancel and hide the given notification previously displayed
    * with showAlertNotification().
    *
-   * @param name         The name of the notification.
+   * @param aName        The name of the notification.
    */
-  void onCancel(in AString name);
+  void onCancel(in AString aName);
 };
 
 [scriptable, uuid(fc6d7f0a-0cf6-4268-8c71-ab640842b9b1)]
@@ -216,13 +254,13 @@
   /**
    * Shows an alert with an icon. Web notifications use the favicon of the
    * page that created the alert. If the favicon is not in the Places database,
-   * |iconSize| will be zero.
+   * |aIconSize| will be zero.
   */
-  void showAlertWithIconData(in nsIAlertNotification alert,
-                             [optional] in nsIObserver alertListener,
-                             [optional] in uint32_t iconSize,
-                             [const, array, size_is(iconSize)] in uint8_t
-                                                               iconData);
+  void showAlertWithIconData(in nsIAlertNotification aAlert,
+                             [optional] in nsIObserver aAlertListener,
+                             [optional] in uint32_t aIconSize,
+                             [const, array, size_is(aIconSize)] in uint8_t
+                                                                aIconData);
 };
 
 [scriptable, uuid(f3c82915-bf60-41ea-91ce-6c46b22e381a)]
@@ -231,9 +269,9 @@
   /**
    * Shows an alert with an icon URI. Web notifications use |moz-anno:|
    * URIs to reference favicons from Places. If the page doesn't have a
-   * favicon, |iconURI| will be |null|.
+   * favicon, |aIconURI| will be |null|.
    */
-  void showAlertWithIconURI(in nsIAlertNotification alert,
-                            [optional] in nsIObserver alertListener,
-                            [optional] in nsIURI iconURI);
+  void showAlertWithIconURI(in nsIAlertNotification aAlert,
+                            [optional] in nsIObserver aAlertListener,
+                            [optional] in nsIURI aIconURI);
 };
diff -urN a/toolkit/components/alerts/nsXULAlerts.h b/toolkit/components/alerts/nsXULAlerts.h
--- a/toolkit/components/alerts/nsXULAlerts.h	2016-06-01 07:11:40.000000000 +0300
+++ b/toolkit/components/alerts/nsXULAlerts.h	2016-09-18 16:58:23.402616230 +0300
@@ -6,6 +6,7 @@
 #ifndef nsXULAlerts_h__
 #define nsXULAlerts_h__
 
+#include "nsCycleCollectionParticipant.h"
 #include "nsHashKeys.h"
 #include "nsInterfaceHashtable.h"
 
diff -urN a/toolkit/components/alerts/test/image_server.sjs b/toolkit/components/alerts/test/image_server.sjs
--- a/toolkit/components/alerts/test/image_server.sjs	1970-01-01 03:00:00.000000000 +0300
+++ b/toolkit/components/alerts/test/image_server.sjs	2016-09-18 16:58:23.403616231 +0300
@@ -0,0 +1,82 @@
+const { classes: Cc, interfaces: Ci, utils: Cu, results: Cr, Constructor: CC } = Components;
+
+Cu.import("resource://gre/modules/Timer.jsm");
+
+const LocalFile = CC("@mozilla.org/file/local;1", "nsILocalFile",
+                     "initWithPath");
+
+const FileInputStream = CC("@mozilla.org/network/file-input-stream;1",
+                           "nsIFileInputStream", "init");
+
+const BinaryInputStream = CC("@mozilla.org/binaryinputstream;1",
+                             "nsIBinaryInputStream", "setInputStream");
+
+function handleRequest(request, response) {
+  let params = parseQueryString(request.queryString);
+
+  response.setStatusLine(request.httpVersion, 200, "OK");
+
+  // Compare and increment a cookie for this request. This is used to test
+  // private browsing mode; the cookie should not be set if the image is
+  // loaded anonymously.
+  if (params.has("c")) {
+    let expectedValue = parseInt(params.get("c"), 10);
+    let actualValue = !request.hasHeader("Cookie") ? 0 :
+                      parseInt(request.getHeader("Cookie")
+                                      .replace(/^counter=(\d+)/, "$1"), 10);
+    if (actualValue != expectedValue) {
+      response.setStatusLine(request.httpVersion, 400, "Wrong counter value");
+      return;
+    }
+    response.setHeader("Set-Cookie", `counter=${expectedValue + 1}`, false);
+  }
+
+  // Wait to send the image if a timeout is given.
+  let timeout = parseInt(params.get("t"), 10);
+  if (timeout > 0) {
+    response.processAsync();
+    setTimeout(() => {
+      respond(params, request, response);
+      response.finish();
+    }, timeout * 1000);
+    return;
+  }
+
+  respond(params, request, response);
+}
+
+function parseQueryString(queryString) {
+  return queryString.split("&").reduce((params, param) => {
+    let [key, value] = param.split("=", 2);
+    params.set(key, value);
+    return params;
+  }, new Map());
+}
+
+function respond(params, request, response) {
+  if (params.has("s")) {
+    let statusCode = parseInt(params.get("s"), 10);
+    response.setStatusLine(request.httpVersion, statusCode, "Custom status");
+    return;
+  }
+  var filename = params.get("f");
+  writeFile(filename, response);
+}
+
+function writeFile(name, response) {
+  var file = new LocalFile(getState("__LOCATION__")).parent;
+  file.append(name);
+
+  let mimeType = Cc["@mozilla.org/uriloader/external-helper-app-service;1"]
+                   .getService(Ci.nsIMIMEService)
+                   .getTypeFromFile(file);
+
+  let fileStream = new FileInputStream(file, 1, 0, false);
+  let binaryStream = new BinaryInputStream(fileStream);
+
+  response.setHeader("Content-Type", mimeType, false);
+  response.bodyOutputStream.writeFrom(binaryStream, binaryStream.available());
+
+  binaryStream.close();
+  fileStream.close();
+}
diff -urN a/toolkit/components/alerts/test/mochitest.ini b/toolkit/components/alerts/test/mochitest.ini
--- a/toolkit/components/alerts/test/mochitest.ini	2016-07-25 23:22:05.000000000 +0300
+++ b/toolkit/components/alerts/test/mochitest.ini	2016-09-18 16:58:23.403616231 +0300
@@ -1,11 +1,16 @@
 [DEFAULT]
 skip-if = buildapp == 'b2g' || buildapp == 'mulet'
+support-files =
+  image.gif
+  image.png
+  image_server.sjs
 
 # Synchronous tests like test_alerts.html must come before
 # asynchronous tests like test_alerts_noobserve.html!
 [test_alerts.html]
 skip-if = toolkit == 'android'
 [test_alerts_noobserve.html]
+[test_image.html]
 [test_multiple_alerts.html]
 [test_principal.html]
 skip-if = toolkit == 'android' || (e10s && os == 'win') # Win: Bug 1264842
diff -urN a/toolkit/components/alerts/test/mochitest.ini.orig b/toolkit/components/alerts/test/mochitest.ini.orig
--- a/toolkit/components/alerts/test/mochitest.ini.orig	1970-01-01 03:00:00.000000000 +0300
+++ b/toolkit/components/alerts/test/mochitest.ini.orig	2016-07-25 23:22:05.000000000 +0300
@@ -0,0 +1,11 @@
+[DEFAULT]
+skip-if = buildapp == 'b2g' || buildapp == 'mulet'
+
+# Synchronous tests like test_alerts.html must come before
+# asynchronous tests like test_alerts_noobserve.html!
+[test_alerts.html]
+skip-if = toolkit == 'android'
+[test_alerts_noobserve.html]
+[test_multiple_alerts.html]
+[test_principal.html]
+skip-if = toolkit == 'android' || (e10s && os == 'win') # Win: Bug 1264842
diff -urN a/toolkit/components/alerts/test/test_image.html b/toolkit/components/alerts/test/test_image.html
--- a/toolkit/components/alerts/test/test_image.html	1970-01-01 03:00:00.000000000 +0300
+++ b/toolkit/components/alerts/test/test_image.html	2016-09-18 16:58:23.403616231 +0300
@@ -0,0 +1,118 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>Test for Bug 1233086</title>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SpawnTask.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+
+<body>
+<p id="display"></p>
+
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+const Cc = SpecialPowers.Cc;
+const Ci = SpecialPowers.Ci;
+const Services = SpecialPowers.Services;
+
+const imageServerURL = "http://mochi.test:8888/tests/toolkit/components/alerts/test/image_server.sjs";
+
+function makeAlert(...params) {
+  var alert = Cc["@mozilla.org/alert-notification;1"]
+                .createInstance(Ci.nsIAlertNotification);
+  alert.init(...params);
+  return alert;
+}
+
+function promiseImage(alert, timeout = 0, userData = null) {
+  return new Promise(resolve => {
+    var isDone = false;
+    function done(value) {
+      ok(!isDone, "Should call the image listener once");
+      isDone = true;
+      resolve(value);
+    }
+    alert.loadImage(timeout, SpecialPowers.wrapCallbackObject({
+      onImageReady(userData, request) {
+        done([true, request, userData]);
+      },
+      onImageMissing(userData) {
+        done([false, userData]);
+      },
+    }), SpecialPowers.wrap(userData));
+  });
+}
+
+add_task(function* testContext() {
+  var inUserData = Cc["@mozilla.org/supports-PRInt64;1"]
+                     .createInstance(Ci.nsISupportsPRInt64);
+  inUserData.data = 123;
+
+  var alert = makeAlert(null, imageServerURL + "?f=image.png");
+  var [ready, request, userData] = yield promiseImage(alert, 0, inUserData);
+  ok(ready, "Should load requested image");
+  is(userData.QueryInterface(Ci.nsISupportsPRInt64).data, 123,
+     "Should pass user data for loaded image");
+
+  alert = makeAlert(null, imageServerURL + "?s=404");
+  [ready, userData] = yield promiseImage(alert, 0, inUserData);
+  ok(!ready, "Should not load missing image");
+  is(userData.QueryInterface(Ci.nsISupportsPRInt64).data, 123,
+     "Should pass user data for missing image");
+});
+
+add_task(function* testTimeout() {
+  var alert = makeAlert(null, imageServerURL + "?f=image.png&t=3");
+  var [ready] = yield promiseImage(alert, 1000);
+  ok(!ready, "Should cancel request if timeout fires");
+
+  [ready, request] = yield promiseImage(alert, 45000);
+  ok(ready, "Should load image if request finishes before timeout");
+});
+
+add_task(function* testAnimatedGIF() {
+  var alert = makeAlert(null, imageServerURL + "?f=image.gif");
+  var [ready, request] = yield promiseImage(alert);
+  ok(ready, "Should load first animated GIF frame");
+  is(request.mimeType, "image/gif", "Should report correct GIF MIME type");
+  is(request.image.width, 256, "GIF width should be 256px");
+  is(request.image.height, 256, "GIF height should be 256px");
+});
+
+add_task(function* testCancel() {
+  var alert = makeAlert(null, imageServerURL + "?f=image.gif&t=180");
+  yield new Promise((resolve, reject) => {
+    var request = alert.loadImage(0, SpecialPowers.wrapCallbackObject({
+      onImageReady(userData, request) {
+        reject(new Error("Should not load cancelled request"));
+      },
+      onImageMissing(userData) {
+        resolve();
+      },
+    }), null);
+    request.cancel(SpecialPowers.Cr.NS_BINDING_ABORTED);
+  });
+});
+
+add_task(function* testMixedContent() {
+  // Loading principal is HTTPS; image URL is HTTP.
+  var origin = "https://mochi.test:8888";
+  var principal = Services.scriptSecurityManager
+                          .createCodebasePrincipalFromOrigin(origin);
+
+  var alert = makeAlert(null, imageServerURL + "?f=image.png",
+                        null, null, false, null, null, null,
+                        null, principal);
+  var [ready, request] = yield promiseImage(alert);
+  ok(ready, "Should load cross-protocol image");
+  is(request.mimeType, "image/png", "Should report correct MIME type");
+  is(request.image.width, 32, "Width should be 32px");
+  is(request.image.height, 32, "Height should be 32px");
+});
+
+</script>
+</pre>
+</body>
+</html>
diff -urN a/toolkit/system/gnome/nsAlertsIconListener.cpp b/toolkit/system/gnome/nsAlertsIconListener.cpp
--- a/toolkit/system/gnome/nsAlertsIconListener.cpp	2016-06-01 07:11:43.000000000 +0300
+++ b/toolkit/system/gnome/nsAlertsIconListener.cpp	2016-09-18 17:04:52.991749258 +0300
@@ -5,12 +5,12 @@
 
 #include "nsAlertsIconListener.h"
 #include "imgIContainer.h"
-#include "imgILoader.h"
 #include "imgIRequest.h"
 #include "nsNetUtil.h"
 #include "nsServiceManagerUtils.h"
 #include "nsSystemAlertsService.h"
 #include "nsIAlertsService.h"
+#include "nsICancelable.h"
 #include "nsIImageToPixbuf.h"
 #include "nsIStringBundle.h"
 #include "nsIObserverService.h"
@@ -71,14 +71,13 @@
   return imgToPixbuf->ConvertImageToPixbuf(image);
 }
 
-NS_IMPL_ISUPPORTS(nsAlertsIconListener, imgINotificationObserver,
+NS_IMPL_ISUPPORTS(nsAlertsIconListener, nsIAlertNotificationImageListener,
                   nsIObserver, nsISupportsWeakReference)
 
 nsAlertsIconListener::nsAlertsIconListener(nsSystemAlertsService* aBackend,
                                            const nsAString& aAlertName)
 : mAlertName(aAlertName),
   mBackend(aBackend),
-  mLoadedFrame(false),
   mNotification(nullptr)
 {
   if (!libNotifyHandle && !libNotifyNotAvail) {
@@ -109,65 +108,20 @@
 nsAlertsIconListener::~nsAlertsIconListener()
 {
   mBackend->RemoveListener(mAlertName, this);
-  if (mIconRequest)
-    mIconRequest->CancelAndForgetObserver(NS_BINDING_ABORTED);
   // Don't dlclose libnotify as it uses atexit().
 }
 
 NS_IMETHODIMP
-nsAlertsIconListener::Notify(imgIRequest *aRequest, int32_t aType, const nsIntRect* aData)
+nsAlertsIconListener::OnImageMissing(nsISupports*)
 {
-  if (aType == imgINotificationObserver::LOAD_COMPLETE) {
-    return OnLoadComplete(aRequest);
-  }
-
-  if (aType == imgINotificationObserver::FRAME_COMPLETE) {
-    return OnFrameComplete(aRequest);
-  }
-
-  return NS_OK;
-}
-
-nsresult
-nsAlertsIconListener::OnLoadComplete(imgIRequest* aRequest)
-{
-  NS_ASSERTION(mIconRequest == aRequest, "aRequest does not match!");
-
-  uint32_t imgStatus = imgIRequest::STATUS_ERROR;
-  nsresult rv = aRequest->GetImageStatus(&imgStatus);
-  NS_ENSURE_SUCCESS(rv, rv);
-  if ((imgStatus & imgIRequest::STATUS_ERROR) && !mLoadedFrame) {
-    // We have an error getting the image. Display the notification with no icon.
-    ShowAlert(nullptr);
-
-    // Cancel any pending request
-    mIconRequest->Cancel(NS_BINDING_ABORTED);
-    mIconRequest = nullptr;
-  }
-
-  nsCOMPtr<imgIContainer> image;
-  rv = aRequest->GetImage(getter_AddRefs(image));
-  if (NS_WARN_IF(NS_FAILED(rv) || !image)) {
-    return rv;
-  }
-
-  // Ask the image to decode at its intrinsic size.
-  int32_t width = 0, height = 0;
-  image->GetWidth(&width);
-  image->GetHeight(&height);
-  image->RequestDecodeForSize(nsIntSize(width, height), imgIContainer::FLAG_NONE);
-
-  return NS_OK;
+  // This notification doesn't have an image, or there was an error getting
+  // the image. Show the notification without an icon.
+  return ShowAlert(nullptr);
 }
 
-nsresult
-nsAlertsIconListener::OnFrameComplete(imgIRequest* aRequest)
+NS_IMETHODIMP
+nsAlertsIconListener::OnImageReady(nsISupports*, imgIRequest* aRequest)
 {
-  NS_ASSERTION(mIconRequest == aRequest, "aRequest does not match!");
-
-  if (mLoadedFrame)
-    return NS_OK; // only use one frame
-
   GdkPixbuf* imagePixbuf = GetPixbufFromImgRequest(aRequest);
   if (!imagePixbuf) {
     ShowAlert(nullptr);
@@ -176,12 +130,6 @@
     g_object_unref(imagePixbuf);
   }
 
-  mLoadedFrame = true;
-
-  // Cancel any pending request (multipart image loading/decoding for instance)
-  mIconRequest->Cancel(NS_BINDING_ABORTED);
-  mIconRequest = nullptr;
-
   return NS_OK;
 }
 
@@ -234,37 +182,6 @@
   return NS_OK;
 }
 
-nsresult
-nsAlertsIconListener::StartRequest(const nsAString & aImageUrl, bool aInPrivateBrowsing)
-{
-  if (mIconRequest) {
-    // Another icon request is already in flight.  Kill it.
-    mIconRequest->Cancel(NS_BINDING_ABORTED);
-    mIconRequest = nullptr;
-  }
-
-  nsCOMPtr<nsIURI> imageUri;
-  NS_NewURI(getter_AddRefs(imageUri), aImageUrl);
-  if (!imageUri)
-    return ShowAlert(nullptr);
-
-  nsCOMPtr<imgILoader> il(do_GetService("@mozilla.org/image/loader;1"));
-  if (!il)
-    return ShowAlert(nullptr);
-
-  nsresult rv = il->LoadImageXPCOM(imageUri, nullptr, nullptr,
-                                   NS_LITERAL_STRING("default"), nullptr, nullptr,
-                                   this, nullptr,
-                                   aInPrivateBrowsing ? nsIRequest::LOAD_ANONYMOUS :
-                                                        nsIRequest::LOAD_NORMAL,
-                                   nullptr, 0 /* use default */,
-                                   getter_AddRefs(mIconRequest));
-  if (NS_FAILED(rv))
-    return rv;
-
-  return NS_OK;
-}
-
 void
 nsAlertsIconListener::SendCallback()
 {
@@ -399,14 +316,8 @@
   rv = aAlert->GetCookie(mAlertCookie);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  nsAutoString imageUrl;
-  rv = aAlert->GetImageURL(imageUrl);
-  NS_ENSURE_SUCCESS(rv, rv);
-  bool inPrivateBrowsing;
-  rv = aAlert->GetInPrivateBrowsing(&inPrivateBrowsing);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  return StartRequest(imageUrl, inPrivateBrowsing);
+  return aAlert->LoadImage(/* aTimeout = */ 0, this, /* aUserData = */ nullptr,
+                           getter_AddRefs(mIconRequest));
 }
 
 void nsAlertsIconListener::NotifyFinished()
diff -urN a/toolkit/system/gnome/nsAlertsIconListener.h b/toolkit/system/gnome/nsAlertsIconListener.h
--- a/toolkit/system/gnome/nsAlertsIconListener.h	2016-06-01 07:11:43.000000000 +0300
+++ b/toolkit/system/gnome/nsAlertsIconListener.h	2016-09-18 17:02:29.392697329 +0300
@@ -7,26 +7,26 @@
 #define nsAlertsIconListener_h__
 
 #include "nsCOMPtr.h"
-#include "imgINotificationObserver.h"
+#include "nsIAlertsService.h"
 #include "nsString.h"
 #include "nsIObserver.h"
 #include "nsWeakReference.h"
 
 #include <gdk-pixbuf/gdk-pixbuf.h>
 
-class imgIRequest;
 class nsIAlertNotification;
+class nsICancelable;
 class nsSystemAlertsService;
 
 struct NotifyNotification;
 
-class nsAlertsIconListener : public imgINotificationObserver,
+class nsAlertsIconListener : public nsIAlertNotificationImageListener,
                              public nsIObserver,
                              public nsSupportsWeakReference
 {
 public:
   NS_DECL_ISUPPORTS
-  NS_DECL_IMGINOTIFICATIONOBSERVER
+  NS_DECL_NSIALERTNOTIFICATIONIMAGELISTENER
   NS_DECL_NSIOBSERVER
 
   nsAlertsIconListener(nsSystemAlertsService* aBackend,
@@ -42,9 +42,6 @@
 protected:
   virtual ~nsAlertsIconListener();
 
-  nsresult OnLoadComplete(imgIRequest* aRequest);
-  nsresult OnFrameComplete(imgIRequest* aRequest);
-
   /**
    * The only difference between libnotify.so.4 and libnotify.so.1 for these symbols
    * is that notify_notification_new takes three arguments in libnotify.so.4 and
@@ -61,7 +58,7 @@
   typedef void (*notify_notification_add_action_t)(void*, const char*, const char*, NotifyActionCallback, gpointer, GFreeFunc);
   typedef bool (*notify_notification_close_t)(void*, GError**);
 
-  nsCOMPtr<imgIRequest> mIconRequest;
+  nsCOMPtr<nsICancelable> mIconRequest;
   nsCString mAlertTitle;
   nsCString mAlertText;
 
@@ -71,7 +68,6 @@
 
   RefPtr<nsSystemAlertsService> mBackend;
 
-  bool mLoadedFrame;
   bool mAlertHasAction;
 
   static void* libNotifyHandle;
@@ -87,7 +83,6 @@
   NotifyNotification* mNotification;
   gulong mClosureHandler;
 
-  nsresult StartRequest(const nsAString & aImageUrl, bool aInPrivateBrowsing);
   nsresult ShowAlert(GdkPixbuf* aPixbuf);
 
   void NotifyFinished();
